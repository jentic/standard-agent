compose: |
  <role>
  You are an expert workflow composer. Using only the structured context below,
  produce a portable, vendor-neutral Arazzo 1.0.1 workflow YAML that captures the
  successful agent workflow. Do not include any auth fields.
  </role>

  <structured_context>
  Goal: {goal_text}
  Tools: {tools_json}
  GeneratedParams: {params_json}
  Executions: {executions_json}
  PlanSteps (optional): {plan_steps_json}
  </structured_context>

  <hard_rules>
  - Auth is out of scope; do not include any auth fields.
  - sourceDescriptions: for each unique Tools[i].api_name create an entry:
      name: safe slug of api_name (non-alphanumerics → '-')
      url: jentic/oak/{{api_name}}
      type: openapi
  - Steps MUST follow Executions order exactly; one step per execution.
  - operationPath for a step: Tools[tool_id].path (verbatim).
  - Parameters for a step: INTERSECTION of GeneratedParams[tool_id].keys and
    Tools[tool_id].parameters.allowed/required (when available).
  - Path templated params: if operationPath contains '{{param}}', map it with in: path.
  - Remaining params: prefer in: query for typical filters (e.g., q, begin_date, end_date, sort, limit, page);
    otherwise place under requestBody.payload.
  - Chaining: when a param value can be sourced from a prior step's outputs, you MUST replace
    $inputs.<param> with $steps.<prevStepId>.outputs.<key>.
  - Outputs per step: expose at least one meaningful value with $response.body#/… (prefer ids; else top-level
    business fields; final fallback: result: $response.body#/).
  - Workflow inputs: the union of parameters still referencing $inputs.* after chaining; do not include values
    produced by prior steps.
  - Workflow outputs: one concise, goal-aligned value (e.g., final id/status/count).
  </hard_rules>

  <construction_plan>
  1) Build sourceDescriptions from Tools (api_name → url jentic/oak/{{api_name}}).
  2) For each Execution in order:
     - Resolve tool metadata (path, parameters.allowed/required) by tool_id.
     - Compute candidate params via intersection of GeneratedParams and parameters.allowed/required.
     - Initialize param values to $inputs.<param>.
     - If PlanSteps exists, use its input_keys to suggest chaining; otherwise, chain from prior outputs when semantically aligned
       (ids/docs/text), replacing $inputs.<param> with $steps.<prevId>.outputs.<key>.
     - Add successCriteria: $statusCode == 200.
     - Add outputs with JSON pointers (ids preferred).
  3) Compute workflow inputs (remaining $inputs.*) and a sensible workflow output based on Goal.
  </construction_plan>

  <requirements>
  - Output MUST be valid Arazzo 1.0.x JSON.
  - Keep stepIds concise (kebab-case) and output keys snake_case.
  - No extra text or fences; JSON only.
  </requirements>

  <output>
  Return ONLY the Arazzo JSON object, no fences, no extra prose.
  </output>
  
  **STRICT OUTPUT REQUIREMENTS:**
  1.  **ONLY Output JSON:** The entire output **MUST** be a single, valid JSON object conforming to the Arazzo schema below. Do **NOT** include any text before or after the JSON object (like "```json" or explanations). The response should be a valid json that can be loaded using `json.loads()`.
  2.  **Conform to Schema:** The output structure **MUST** strictly follow the Arazzo JSON Schema provided below. Pay close attention to required fields and data types.
  3.  **Valid References:** All `$steps.*` references **MUST** point to `outputs` defined in prior steps within the same workflow. All `$inputs.*` references **MUST** point to inputs defined in the workflow's `inputs` section (or components).
  4.  **Completeness:** Ensure all required fields in the Arazzo schema are present (e.g., `arazzo`, `info`, `sourceDescriptions`, `workflows`, `workflowId`, `stepId`, `operationId`/`operationPath`).
  5.  **No Additional Fields:** Do not add any fields not defined in the Arazzo schema to the core objects (e.g., no `contact`, `license` in `info`). Specification Extensions (`x-*`) are allowed if appropriate but not required.
  6.  **Multi-Step Workflows Only:** Do not generate one-step workflows. Any workflow **MUST** have at least two steps. If you cannot generate valid meaningful multi-step workflows, output an empty `workflows` array (`[]`).
  8. **Add Success Criteria:** Every step **MUST** include a `successCriteria` array. Typically, this should check for a successful HTTP status code (e.g., `[{{ "condition": "$statusCode >= 200 && $statusCode < 300" }}]` or `[{{ "condition": "$statusCode == 200" }}]`). Refer to the openapi endpoint operation responses for the expected status codes.
  9. **Implement Failure Handling:**
      *   **Default:** For each step, add an `onFailure` array. By default, this should contain a single action of type `end` to terminate the workflow cleanly upon step failure. The action **MUST** have a descriptive `name` (e.g., `end-on-get-item-fail`).
      *   **Alternative (Workflow Level):** You MAY use workflow-level `failureActions` instead of step-level `onFailure` *if* a single, global failure policy (like `end` or a specific `retry`) is appropriate for *all* steps in that workflow. If `failureActions` is used, do *not* add `onFailure` to the steps within that specific workflow.
      *   **Priority:** Prefer step-level `onFailure` with a simple `end` action unless there's a clear reason for workflow-level or retry logic.
  
example: |
  
  Minimal Arazzo JSON shape to follow (structure only, not content):
  {
    "arazzo": "1.0.1",
    "info": { "title": "...", "version": "1.0.0", "summary": "...", "description": "..." },
    "sourceDescriptions": [
      { "name": "api-name", "url": "https://...", "type": "openapi" }
    ],
    "workflows": [
      {
        "workflowId": "workflow-id",
        "summary": "...",
        "description": "...",
        "inputs": { "type": "object", "properties": {}, "required": [] },
        "steps": [
          {
            "stepId": "step-1",
            "operationPath": "{$sourceDescriptions.api-name.url}#/paths/.../(get|post)",
            "parameters": [ { "name": "q", "in": "query", "value": "$inputs.q" } ],
            "requestBody": { "contentType": "application/json", "payload": {} },
            "successCriteria": [ { "condition": "$statusCode >= 200 && $statusCode < 300" } ],
            "onFailure": [ { "name": "end-on-step-1-fail", "type": "end" } ],
            "outputs": { "first_result": "$response.body#/items" }
          },
          {
            "stepId": "step-2",
            "operationPath": "{$sourceDescriptions.api-name.url}#/paths/.../(get|post)",
            "parameters": [ { "name": "id", "in": "query", "value": "$inputs.item_id" } ],
            "requestBody": { "contentType": "application/json", "payload": {} },
            "successCriteria": [ { "condition": "$statusCode >= 200 && $statusCode < 300" } ],
            "onFailure": [ { "name": "end-on-step-2-fail", "type": "end" } ],
            "outputs": { "second_result": "$response.body#/summary" }
          },
          {
            "stepId": "step-3",
            "operationPath": "{$sourceDescriptions.api-name.url}#/paths/.../(get|post)",
            "parameters": [
              { "name": "docs", "in": "query", "value": "$steps.step-1.outputs.first_result" },
              { "name": "note", "in": "query", "value": "$steps.step-2.outputs.second_result" }
            ],
            "requestBody": { "contentType": "application/json", "payload": {} },
            "successCriteria": [ { "condition": "$statusCode >= 200 && $statusCode < 300" } ],
            "onFailure": [ { "name": "end-on-step-3-fail", "type": "end" } ],
            "outputs": { "final_id": "$response.body#/id", "final_status": "$response.body#/status" }
          }
        ],
        "outputs": {
          "final_id": "$steps.step-3.outputs.final_id",
          "final_status": "$steps.step-3.outputs.final_status"
        }
      }
    ]
  }

    Example Valid Arazzo Structure (Including Failure Handling):
    {
      "arazzo": "1.0.1",
      "info": {
        "title": "Example API Workflows",
        "version": "1.0.0",
        "description": "Generated workflows based on the provided OpenAPI spec."
      },
      "sourceDescriptions": [
        {
          "name": "api",
          "url": "./openapi.json",
          "type": "openapi"
        }
      ],
      "workflows": [
        {
          "workflowId": "example-workflow-1",
          "summary": "Fetches an item and updates its status.",
          "description": "This workflow retrieves an item by its ID and then updates its status based on user input.",
          "inputs": {
            "type": "object",
            "properties": {
              "itemId": { "type": "string", "description": "ID of the item to process." },
              "newStatus": { "type": "string", "description": "The new status for the item." }
            },
            "required": [ "itemId", "newStatus" ]
          },
          "steps": [
            {
              "stepId": "get-item",
              "description": "Retrieve the item details.",
              "operationId": "getItemById", // MUST match an operationId from { endpoints }
              "parameters": [
                {
                  "name": "id", // MUST match parameter name in OpenAPI spec for getItemById
                  "in": "path", // MUST match parameter location in OpenAPI spec
                  "value": "$inputs.itemId"
                }
              ],
              "successCriteria": [
                { "condition": "$statusCode == 200" }
              ],
              "onFailure": [ // Added step-level failure handling (default: end)
                {
                  "name": "end-on-get-item-fail",
                  "type": "end"
                }
              ],
              "outputs": {
                "item_data": "$response.body" // Assumes response body is the item object
              }
            },
            {
              "stepId": "update-item-status",
              "description": "Update the status of the retrieved item.",
              "operationId": "updateItem", // MUST match an operationId from { endpoints }
              "parameters": [
                {
                  "name": "id", // MUST match parameter name in OpenAPI spec for updateItem
                  "in": "path", // MUST match parameter location in OpenAPI spec
                  "value": "$inputs.itemId" // Or could use "$steps.get-item.outputs.item_data#/id" if ID is in body
                }
              ],
              "requestBody": {
                "contentType": "application/json", // MUST match OpenAPI spec
                "payload": { // Structure MUST match schema from { requestBodies } for updateItem
                  "status": "$inputs.newStatus",
                  "lastUpdated": "$timestamp" // Example of using a built-in context variable
                                   // other fields might reference "$steps.get-item.outputs.item_data#/fieldName"
                }
              },
              "successCriteria": [
                { "condition": "$statusCode == 200" }
              ],
              "onFailure": [ // Added step-level failure handling (default: end)
                {
                  "name": "end-on-update-fail",
                  "type": "end"
                }
              ],
              "outputs": {
                "updated_item_result": "$response.body"
              }
            }
          ],
          "outputs": {
            "final_item_status": "$steps.update-item-status.outputs.updated_item_result#/status" // Example output extraction
          }
        },
        { // EXAMPLE 2: Using Workflow-Level failureActions
            "workflowId": "create-and-notify-workflow-failure",
          "summary": "Creates a resource and sends notification (uses global failure action).",
          "description": "This workflow creates a resource and then sends a notification. A single failure action applies to all steps.",
          "inputs": {
            "type": "object",
            "properties": {
              "resourceName": { "type": "string", "description": "Name for the new resource." },
              "notificationEmail": { "type": "string", "format": "email", "description": "Email for notification." }
            },
            "required": [ "resourceName", "notificationEmail" ]
          },
          "failureActions": [ // Workflow-level failure handling (applies to all steps below)
            {
              "name": "end-workflow-on-any-step-failure",
              "type": "end"
            }
          ],
          "steps": [
            {
              "stepId": "create-resource",
              "description": "Create the new resource.",
              "operationId": "createResource", // MUST match an operationId from { endpoints }
              "requestBody": {
                "contentType": "application/json",
                "payload": { "name": "$inputs.resourceName" }
              },
              "successCriteria": [ { "condition": "$statusCode == 201" } ],
              // No onFailure here - the workflow-level action applies
              "outputs": { "new_resource_id": "$response.body#/id" }
            },
            {
              "stepId": "send-notification",
              "description": "Send a notification about the new resource.",
              "operationId": "sendNotification", // MUST match an operationId from { endpoints }
              "requestBody": {
                "contentType": "application/json",
                "payload": {
                  "recipient": "$inputs.notificationEmail",
                  "subject": "New Resource Created",
                  "body": "Resource ID $steps.create-resource.outputs.new_resource_id has been created."
                }
              },
              "successCriteria": [ { "condition": "$statusCode == 202" } ]
                                   // No onFailure here - the workflow-level action applies
            }
          ],
          "outputs": {
            "createdResourceId": "$steps.create-resource.outputs.new_resource_id"
          }
        }
        // Potentially more workflow objects here...
      ],
      "components": { // Optional section
        "inputs": {
          "shared_user_id_input": {
            "type": "string", "description": "A reusable user ID input."
          }
        }
      }
    }
  
  
